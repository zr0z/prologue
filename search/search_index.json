{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prologue What's past is prologue. Purpose Prologue is a web framework written in Nim. It is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise. Documentation Documentation Index Page Core API Index Page Search Page Full API Index Page Search Page Installation First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Prologue also provides some extensions. You can use logue extension to install all of them. If you just want to install one of them, you can use logue extension module for example logue extension redis . Usage Hello World # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let app = newApp () app . addRoute ( \"/\" , hello ) app . run () Run app.nim ( nim c -r app.nim ). Now the server is running at localhost:8080 . Another example # app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"Prologue\" ) var app = newApp ( settings = settings ) app . use ( debugRequestMiddleware ()) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim ( nim c -r app.nim ). Now the server is running at localhost:8080 . More examples HelloWorld ToDoList ToDoApp Blog Additional examples repository Extensions If you need more extensions, you can refer to awesome prologue and awesome nim . Donations Thanks for supporting me. buy me a coffee patreon Stars","title":"Introduction"},{"location":"#prologue","text":"What's past is prologue.","title":"Prologue"},{"location":"#purpose","text":"Prologue is a web framework written in Nim. It is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise.","title":"Purpose"},{"location":"#documentation","text":"Documentation Index Page Core API Index Page Search Page Full API Index Page Search Page","title":"Documentation"},{"location":"#installation","text":"First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Prologue also provides some extensions. You can use logue extension to install all of them. If you just want to install one of them, you can use logue extension module for example logue extension redis .","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#hello-world","text":"# app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let app = newApp () app . addRoute ( \"/\" , hello ) app . run () Run app.nim ( nim c -r app.nim ). Now the server is running at localhost:8080 .","title":"Hello World"},{"location":"#another-example","text":"# app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"Prologue\" ) var app = newApp ( settings = settings ) app . use ( debugRequestMiddleware ()) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim ( nim c -r app.nim ). Now the server is running at localhost:8080 .","title":"Another example"},{"location":"#more-examples","text":"HelloWorld ToDoList ToDoApp Blog Additional examples repository","title":"More examples"},{"location":"#extensions","text":"If you need more extensions, you can refer to awesome prologue and awesome nim .","title":"Extensions"},{"location":"#donations","text":"Thanks for supporting me. buy me a coffee patreon","title":"Donations"},{"location":"#stars","text":"","title":"Stars"},{"location":"cli/","text":"Command line tool Prologue ships with logue tool to help you start a new project quickly. Creates a new project Type logue init projectName in command line to create a new project. This will create .env file for configuration. If you want to use JSON format config file, please add --useConfig or -u to the command. logue init newapp Using json config: logue init newapp --useConfig # or logue init newapp -u Install the extensions Type logue extension extensionName to install the specific extension which is specified in prologue.nimble . If you want to install all the extensions, please input logue extension all . logue extension redis Install all the extensions: logue extension all","title":"Command Line Tool"},{"location":"cli/#command-line-tool","text":"Prologue ships with logue tool to help you start a new project quickly.","title":"Command line tool"},{"location":"cli/#creates-a-new-project","text":"Type logue init projectName in command line to create a new project. This will create .env file for configuration. If you want to use JSON format config file, please add --useConfig or -u to the command. logue init newapp Using json config: logue init newapp --useConfig # or logue init newapp -u","title":"Creates a new project"},{"location":"cli/#install-the-extensions","text":"Type logue extension extensionName to install the specific extension which is specified in prologue.nimble . If you want to install all the extensions, please input logue extension all . logue extension redis Install all the extensions: logue extension all","title":"Install the extensions"},{"location":"configure/","text":"Configuration When starting a project, you need to configure your application. Simple settings For small program, you could use the default settings which is provided by Prologue . import prologue var app = newApp () app . run () You may want to specify settings by yourself. Prologue provides newSettings function to create a new settings. The program below creates a new settings with debug = false . This will disable the default logging. import prologue let settings = newSettings ( debug = false ) var app = newApp ( settings = settings ) app . run () You can also read settings from .env file. Prologue provides loadPrologueEnv to read data from .env file. You can use get or getOrDefault to retrieve the value. import prologue let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )) ) var app = newApp ( settings = settings ) app . run () Config file You need to specify a config file for a big project. Prologue provides loadSettings to read JSON file. You should give the path of the Json config file. let settings = loadSettings ( \".config/config.debug.json\" ) var app = newApp ( settings ) .config/config.debug.json In config file, the prologue key must be present. The corresponding data will be used by framework. Among the corresponding data, the secretKey must be present and should not be empty. Otherwise, the program will raise exception. Other keys can be absent, they will be given a default value setting by Prologue . Below is the type of settings: address: string port: int debug: bool reusePort: bool appName: string secretKey: string bufSize: int { \"prologue\" : { \"address\" : \"\" , \"port\" : 8080 , \"debug\" : true , \"reusePort\" : true , \"appName\" : \"\" , \"secretKey\" : \"Set by yourself\" , \"bufSize\" : 40960 }, \"name\" : \"debug\" } Prologue also supports automatically loading configure file by environment variables. The .config directory must be present in the current path(in the same directory as the main program). If you don't set the environment variable(namely PROLOGUE ) or the value is default , the application will read .config/config.json file. Otherwise, if you set the PROLOGUE environment variable to custom , the application will read .config/config.custom.json . The common names includes debug and production . If the file doesn't exist, it will raise exception. import prologue var app = newAppQueryEnv () app . run ()","title":"Configure"},{"location":"configure/#configuration","text":"When starting a project, you need to configure your application.","title":"Configuration"},{"location":"configure/#simple-settings","text":"For small program, you could use the default settings which is provided by Prologue . import prologue var app = newApp () app . run () You may want to specify settings by yourself. Prologue provides newSettings function to create a new settings. The program below creates a new settings with debug = false . This will disable the default logging. import prologue let settings = newSettings ( debug = false ) var app = newApp ( settings = settings ) app . run () You can also read settings from .env file. Prologue provides loadPrologueEnv to read data from .env file. You can use get or getOrDefault to retrieve the value. import prologue let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )) ) var app = newApp ( settings = settings ) app . run ()","title":"Simple settings"},{"location":"configure/#config-file","text":"You need to specify a config file for a big project. Prologue provides loadSettings to read JSON file. You should give the path of the Json config file. let settings = loadSettings ( \".config/config.debug.json\" ) var app = newApp ( settings ) .config/config.debug.json In config file, the prologue key must be present. The corresponding data will be used by framework. Among the corresponding data, the secretKey must be present and should not be empty. Otherwise, the program will raise exception. Other keys can be absent, they will be given a default value setting by Prologue . Below is the type of settings: address: string port: int debug: bool reusePort: bool appName: string secretKey: string bufSize: int { \"prologue\" : { \"address\" : \"\" , \"port\" : 8080 , \"debug\" : true , \"reusePort\" : true , \"appName\" : \"\" , \"secretKey\" : \"Set by yourself\" , \"bufSize\" : 40960 }, \"name\" : \"debug\" } Prologue also supports automatically loading configure file by environment variables. The .config directory must be present in the current path(in the same directory as the main program). If you don't set the environment variable(namely PROLOGUE ) or the value is default , the application will read .config/config.json file. Otherwise, if you set the PROLOGUE environment variable to custom , the application will read .config/config.custom.json . The common names includes debug and production . If the file doesn't exist, it will raise exception. import prologue var app = newAppQueryEnv () app . run ()","title":"Config file"},{"location":"context/","text":"Context Context is initialized when a new request enters. You can get the information of the whole Context when you are writing handlers. You can use attributes of context such as request , response , session and so on. For example, you can get the HTTP method of the request. proc login * ( ctx : Context ) {. async .} = doAssert ctx . request . reqMethod == HttpPost Context utils getPostParams Gets the parameters by HttpPost. proc hello ( ctx : Context ) {. async .} = resp ctx . getPostParams ( \"username\" ) getQueryParams Gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). proc hello ( ctx : Context ) {. async .} = doAssert ctx . getQueryParams ( \"name\" ) == \"12\" getPathParams Gets the route parameters(for example, \"/hello/{name}\"). proc hello ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" getFormParams Gets the contents of the form if key exists. Otherwise default will be returned. If you need the filename of the form, use getUploadFile instead. proc hello ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getFormParams ( \"name\" , \"Prologue\" ) & \"</h1>\" setResponse It is handy to make the response of ctx . proc hello ( ctx : Context ) {. async .} = ctx . setResponse ( Http200 , \"setResponse\" ) attachment attachment is used to specify the file will be downloaded. proc hello ( ctx : Context ) {. async .} = let downloadName = \"test.txt\" ctx . attachment ( downloadName ) staticFileResponse Returns static files response. The following middlewares processing will be discarded. proc hello ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"index.html\" , \"static\" ) getUploadFile Gets the UploadFile from request. UploadFile can be saved to disk using save function. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/local/uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/assets/temp\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\"","title":"Context"},{"location":"context/#context","text":"Context is initialized when a new request enters. You can get the information of the whole Context when you are writing handlers. You can use attributes of context such as request , response , session and so on. For example, you can get the HTTP method of the request. proc login * ( ctx : Context ) {. async .} = doAssert ctx . request . reqMethod == HttpPost","title":"Context"},{"location":"context/#context-utils","text":"","title":"Context utils"},{"location":"context/#getpostparams","text":"Gets the parameters by HttpPost. proc hello ( ctx : Context ) {. async .} = resp ctx . getPostParams ( \"username\" )","title":"getPostParams"},{"location":"context/#getqueryparams","text":"Gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). proc hello ( ctx : Context ) {. async .} = doAssert ctx . getQueryParams ( \"name\" ) == \"12\"","title":"getQueryParams"},{"location":"context/#getpathparams","text":"Gets the route parameters(for example, \"/hello/{name}\"). proc hello ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\"","title":"getPathParams"},{"location":"context/#getformparams","text":"Gets the contents of the form if key exists. Otherwise default will be returned. If you need the filename of the form, use getUploadFile instead. proc hello ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getFormParams ( \"name\" , \"Prologue\" ) & \"</h1>\"","title":"getFormParams"},{"location":"context/#setresponse","text":"It is handy to make the response of ctx . proc hello ( ctx : Context ) {. async .} = ctx . setResponse ( Http200 , \"setResponse\" )","title":"setResponse"},{"location":"context/#attachment","text":"attachment is used to specify the file will be downloaded. proc hello ( ctx : Context ) {. async .} = let downloadName = \"test.txt\" ctx . attachment ( downloadName )","title":"attachment"},{"location":"context/#staticfileresponse","text":"Returns static files response. The following middlewares processing will be discarded. proc hello ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"index.html\" , \"static\" )","title":"staticFileResponse"},{"location":"context/#getuploadfile","text":"Gets the UploadFile from request. UploadFile can be saved to disk using save function. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/local/uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/assets/temp\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\"","title":"getUploadFile"},{"location":"errorhandler/","text":"Error Handler User-defined error pages When web application encounters some unexpected situations, it may send 404 response to the client. You may want to use user-defined 404 pages, then you can use resp to return 404 response. proc hello ( ctx : Context ) {. async .} = resp \"Something is wrong, please retry.\" , Http404 Prologue also provides an error404 helper function to create a 404 response. proc hello ( ctx : Context ) {. async .} = resp error404 ( headers = ctx . response . headers ) Or use errorPage to create a more descriptive error page. proc hello ( ctx : Context ) {. async .} = resp errorPage ( \"Something is wrong\" ), Http404 Default error handler Users can also set the default error handler. When ctx.response.body is empty, web application will use the default error handler. The basic example with respDefault which is equal to resp errorPage(\"Something is wrong\"), Http404 . proc hello ( ctx : Context ) {. async .} = respDefault Http404 Prologue has registered two error handlers before application starts, namely default404Handler for Http404 and default500Handler for Http500 . You can change them using registerErrorHandler . proc go404 * ( ctx : Context ) {. async .} = resp \"Something wrong!\" , Http404 proc go20x * ( ctx : Context ) {. async .} = resp \"Ok!\" , Http200 proc go30x * ( ctx : Context ) {. async .} = resp \"EveryThing else?\" , Http301 app . registerErrorHandler ( Http404 , go404 ) app . registerErrorHandler ({ Http200 .. Http204 }, go20x ) app . registerErrorHandler ( @[ Http301 , Http304 , Http307 ] , go30x ) If you don't want to use the default Error handler, you could clear the whole error handler table. var app = newApp ( errorHandlerTable = newErrorHandlerTable ()) HTTP 500 handler Http 500 indicates the internal error of the framework. In debug mode( settings.debug = true ), the framework will send the exception msgs to the web browser if the length of error msgs is greater than zero. Otherwise, the framework will use the default error handled which has been registered before the application starts. Users could cover this handler by using their own error handler.","title":"Error Handler"},{"location":"errorhandler/#error-handler","text":"","title":"Error Handler"},{"location":"errorhandler/#user-defined-error-pages","text":"When web application encounters some unexpected situations, it may send 404 response to the client. You may want to use user-defined 404 pages, then you can use resp to return 404 response. proc hello ( ctx : Context ) {. async .} = resp \"Something is wrong, please retry.\" , Http404 Prologue also provides an error404 helper function to create a 404 response. proc hello ( ctx : Context ) {. async .} = resp error404 ( headers = ctx . response . headers ) Or use errorPage to create a more descriptive error page. proc hello ( ctx : Context ) {. async .} = resp errorPage ( \"Something is wrong\" ), Http404","title":"User-defined error pages"},{"location":"errorhandler/#default-error-handler","text":"Users can also set the default error handler. When ctx.response.body is empty, web application will use the default error handler. The basic example with respDefault which is equal to resp errorPage(\"Something is wrong\"), Http404 . proc hello ( ctx : Context ) {. async .} = respDefault Http404 Prologue has registered two error handlers before application starts, namely default404Handler for Http404 and default500Handler for Http500 . You can change them using registerErrorHandler . proc go404 * ( ctx : Context ) {. async .} = resp \"Something wrong!\" , Http404 proc go20x * ( ctx : Context ) {. async .} = resp \"Ok!\" , Http200 proc go30x * ( ctx : Context ) {. async .} = resp \"EveryThing else?\" , Http301 app . registerErrorHandler ( Http404 , go404 ) app . registerErrorHandler ({ Http200 .. Http204 }, go20x ) app . registerErrorHandler ( @[ Http301 , Http304 , Http307 ] , go30x ) If you don't want to use the default Error handler, you could clear the whole error handler table. var app = newApp ( errorHandlerTable = newErrorHandlerTable ())","title":"Default error handler"},{"location":"errorhandler/#http-500-handler","text":"Http 500 indicates the internal error of the framework. In debug mode( settings.debug = true ), the framework will send the exception msgs to the web browser if the length of error msgs is greater than zero. Otherwise, the framework will use the default error handled which has been registered before the application starts. Users could cover this handler by using their own error handler.","title":"HTTP 500 handler"},{"location":"event/","text":"Event Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event (A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , startup = @[ event ] )","title":"Event"},{"location":"event/#event","text":"Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event (A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , startup = @[ event ] )","title":"Event"},{"location":"extendctx/","text":"Extend Context Prologue provides flexible way to extend Context . User-defined Context should inherit from the Context from Prologue . You may want to add an int to Context : import prologue import std / strformat type UserContext = ref object of Context data : int proc hello * ( ctx : UserContext ) {. async .} = inc ctx . data echo fmt\"{ctx.data = }\" resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . use ( extendContextMiddleWare ( UserContext )) app . get ( \"/\" , hello ) app . run () You may want to write a middleware: import prologue import std / strformat type UserContext = ref object of Context data : int ExperimentContext = concept ctx ctx is Context ctx . data is int proc experimentMiddleware [ T : ExperimentContext ] ( ctxType : typedesc [ T ] ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = inc ctx . ctxType . data echo fmt\"{ctx.ctxType.data = }\" await switch ( ctx ) proc hello * ( ctx : UserContext ) {. async .} = inc ctx . data echo fmt\"{ctx.data = }\" resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . use ( extendContextMiddleWare ( UserContext )) app . use ( experimentMiddleware ( UserContext )) app . get ( \"/\" , hello ) app . run ()","title":"Extend Context"},{"location":"extendctx/#extend-context","text":"Prologue provides flexible way to extend Context . User-defined Context should inherit from the Context from Prologue . You may want to add an int to Context : import prologue import std / strformat type UserContext = ref object of Context data : int proc hello * ( ctx : UserContext ) {. async .} = inc ctx . data echo fmt\"{ctx.data = }\" resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . use ( extendContextMiddleWare ( UserContext )) app . get ( \"/\" , hello ) app . run () You may want to write a middleware: import prologue import std / strformat type UserContext = ref object of Context data : int ExperimentContext = concept ctx ctx is Context ctx . data is int proc experimentMiddleware [ T : ExperimentContext ] ( ctxType : typedesc [ T ] ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = inc ctx . ctxType . data echo fmt\"{ctx.ctxType.data = }\" await switch ( ctx ) proc hello * ( ctx : UserContext ) {. async .} = inc ctx . data echo fmt\"{ctx.data = }\" resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . use ( extendContextMiddleWare ( UserContext )) app . use ( experimentMiddleware ( UserContext )) app . get ( \"/\" , hello ) app . run ()","title":"Extend Context"},{"location":"faq/","text":"FAQ (1). Prologue supports two HTTP server: httpx and asynchttpserver . The default HTTP server is httpx . If you are in Linux or MacOS, use --threads:on to enable the multi-threads HTTP server. If you are in windows, threads can't speed up the server. You can use -d:usestd to switch to asynchttpserver . (2). If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )), secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8080 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue (3). There are two ways to disable logging messages: set settings.debug = false set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , startup = @[ event ] )","title":"FAQ"},{"location":"faq/#faq","text":"(1). Prologue supports two HTTP server: httpx and asynchttpserver . The default HTTP server is httpx . If you are in Linux or MacOS, use --threads:on to enable the multi-threads HTTP server. If you are in windows, threads can't speed up the server. You can use -d:usestd to switch to asynchttpserver . (2). If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8080 )), secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8080 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue (3). There are two ways to disable logging messages: set settings.debug = false set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , startup = @[ event ] )","title":"FAQ"},{"location":"headers/","text":"Headers Prologue provides two types of headers . One is the headers of request which carries information from the client. The other is the headers of response which carries information sent to the client. The headers of the request The client will send headers to our HTTP server. You may want to check whether some keys are in the headers. If existing, you could get the values of them. The return type of ctx.request.getHeader is seq[string] . You often only need the first element of the sequence. The following code first checks whether the key exists in headers. If true, retrieve the sequence of values and display them in the browser. proc hello ( ctx : Context ) {. async .} = if ctx . request . hasHeader ( \"cookie\" ): let values = ctx . request . getHeader ( \"cookie\" ) resp $ values elif ctx . request . hasHeader ( \"content-type\" ): let values = ctx . request . getHeaderOrDefault ( \"content\" ) resp $ values The headers of the response Prologue also sends HTTP headers to the client. It uses ResponseHeaders to store them. It has similar API like the headers of the request. First, Prologue initializes ctx.response with initResponseHeaders . Then users could use hasHeader , addHeader or setHeader to do what they want. Notes that, addHeader will append values to existing keys in headers. setHeader will reset the values of key no matter whether key is in the headers. proc hello ( ctx : Context ) {. async .} = ctx . response . addHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ] ctx . response . setHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ]","title":"Headers"},{"location":"headers/#headers","text":"Prologue provides two types of headers . One is the headers of request which carries information from the client. The other is the headers of response which carries information sent to the client.","title":"Headers"},{"location":"headers/#the-headers-of-the-request","text":"The client will send headers to our HTTP server. You may want to check whether some keys are in the headers. If existing, you could get the values of them. The return type of ctx.request.getHeader is seq[string] . You often only need the first element of the sequence. The following code first checks whether the key exists in headers. If true, retrieve the sequence of values and display them in the browser. proc hello ( ctx : Context ) {. async .} = if ctx . request . hasHeader ( \"cookie\" ): let values = ctx . request . getHeader ( \"cookie\" ) resp $ values elif ctx . request . hasHeader ( \"content-type\" ): let values = ctx . request . getHeaderOrDefault ( \"content\" ) resp $ values","title":"The headers of the request"},{"location":"headers/#the-headers-of-the-response","text":"Prologue also sends HTTP headers to the client. It uses ResponseHeaders to store them. It has similar API like the headers of the request. First, Prologue initializes ctx.response with initResponseHeaders . Then users could use hasHeader , addHeader or setHeader to do what they want. Notes that, addHeader will append values to existing keys in headers. setHeader will reset the values of key no matter whether key is in the headers. proc hello ( ctx : Context ) {. async .} = ctx . response . addHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ] ctx . response . setHeader ( \"Content-Type\" , \"text/plain\" ) doAssert ctx . response . getHeader ( \"CONTENT-TYPE\" ) == @[ \"text/html; charset=UTF-8\" , \"text/plain\" ]","title":"The headers of the response"},{"location":"middleware/","text":"Middlewares Write a middleware Middleware is like an onion. a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter the next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Prologue\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var app = newApp () app . use ( myDebugRequestMiddleware ()) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can also put some variables in closure environments, but be careful it is error-prone when using multi-threads. You must know the differences between GC options(thread local heap vs shared heap) and what's the use of gcsafe . proc sessionMiddleware (): HandleAsync = var memorySessionTable = newTable [ string , string ] () result = proc ( ctx : Context ) {. async .} = memorySessionTable [ \"test\" ] = \"prologue\" You can put your middleware plugin in collections . Write reusable handler Every handler in Prologue is a closure function. It is flexible to create a reusable components. import prologue proc home ( ctx : Context ) {. async .} = resp \"home\" proc redirectTo ( dest : string ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = resp redirect ( dest ) var app = newApp () app . get ( \"/\" , home ) app . get ( \"/redirect\" , redirectTo ( \"/\" )) app . run () Use built-in middleware prologue also supplies some middleware plugins, you can directly import middlewares . It contains cors , clickjacking , csrf , utils and auth middlewares. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / auth # or import prologue / middlewares / utils # or import prologue / middlewares / cors # or import prologue / middlewares / clickjacking # or import prologue / middlewares / csrf For session middlewares, you need to import them directly. import prologue / middlewares / memorysession # or import prologue / middlewares / redissession # or import prologue / middlewares / signedcookiesession","title":"Middleware"},{"location":"middleware/#middlewares","text":"","title":"Middlewares"},{"location":"middleware/#write-a-middleware","text":"Middleware is like an onion. a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter the next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Prologue\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var app = newApp () app . use ( myDebugRequestMiddleware ()) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can also put some variables in closure environments, but be careful it is error-prone when using multi-threads. You must know the differences between GC options(thread local heap vs shared heap) and what's the use of gcsafe . proc sessionMiddleware (): HandleAsync = var memorySessionTable = newTable [ string , string ] () result = proc ( ctx : Context ) {. async .} = memorySessionTable [ \"test\" ] = \"prologue\" You can put your middleware plugin in collections .","title":"Write a middleware"},{"location":"middleware/#write-reusable-handler","text":"Every handler in Prologue is a closure function. It is flexible to create a reusable components. import prologue proc home ( ctx : Context ) {. async .} = resp \"home\" proc redirectTo ( dest : string ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = resp redirect ( dest ) var app = newApp () app . get ( \"/\" , home ) app . get ( \"/redirect\" , redirectTo ( \"/\" )) app . run ()","title":"Write reusable handler"},{"location":"middleware/#use-built-in-middleware","text":"prologue also supplies some middleware plugins, you can directly import middlewares . It contains cors , clickjacking , csrf , utils and auth middlewares. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / auth # or import prologue / middlewares / utils # or import prologue / middlewares / cors # or import prologue / middlewares / clickjacking # or import prologue / middlewares / csrf For session middlewares, you need to import them directly. import prologue / middlewares / memorysession # or import prologue / middlewares / redissession # or import prologue / middlewares / signedcookiesession","title":"Use built-in middleware"},{"location":"mocking/","text":"Mocking Mocking module can be used for quick test without HTTP server. First use mockApp to add mockingMiddleware to the application. Next create a new mocking request using initMockingRequest . Then run the mocking application with runOnce . Finally check whether ctx meets your requirements. import prologue import prologue / mocking import std / uri proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings ( debug = true ) var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) mockApp ( app ) let url = parseUri ( \"/\" ) let req = initMockingRequest ( httpMethod = HttpGet , headers = newHttpHeaders (), url = url , cookies = initCookieJar (), postParams = newStringTable (), queryParams = newStringTable (), formParams = initFormPart (), pathParams = newStringTable () ) let ctx = app . runOnce ( req ) doAssert ctx . response . code == Http200 doAssert ctx . response . getHeader ( \"content-type\" ) == @[ \"text/html; charset=UTF-8\" ] doAssert ctx . response . body == \"<h1>Hello, Prologue!</h1>\"","title":"Mocking"},{"location":"mocking/#mocking","text":"Mocking module can be used for quick test without HTTP server. First use mockApp to add mockingMiddleware to the application. Next create a new mocking request using initMockingRequest . Then run the mocking application with runOnce . Finally check whether ctx meets your requirements. import prologue import prologue / mocking import std / uri proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings ( debug = true ) var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) mockApp ( app ) let url = parseUri ( \"/\" ) let req = initMockingRequest ( httpMethod = HttpGet , headers = newHttpHeaders (), url = url , cookies = initCookieJar (), postParams = newStringTable (), queryParams = newStringTable (), formParams = initFormPart (), pathParams = newStringTable () ) let ctx = app . runOnce ( req ) doAssert ctx . response . code == Http200 doAssert ctx . response . getHeader ( \"content-type\" ) == @[ \"text/html; charset=UTF-8\" ] doAssert ctx . response . body == \"<h1>Hello, Prologue!</h1>\"","title":"Mocking"},{"location":"openapi/","text":"openapi Prologue supplies minimal supports for openapi docs. You need to write openapi.json by yourself. Then Prologue will register corresponding routes. import prologue import prologue / openapi app . serveDocs ( \"docs/openapi.json\" ) app . run () example for docs/openapi.json . visit localhost:8080/docs or localhost:8080/redocs","title":"OpenAPI"},{"location":"openapi/#openapi","text":"Prologue supplies minimal supports for openapi docs. You need to write openapi.json by yourself. Then Prologue will register corresponding routes. import prologue import prologue / openapi app . serveDocs ( \"docs/openapi.json\" ) app . run () example for docs/openapi.json . visit localhost:8080/docs or localhost:8080/redocs","title":"openapi"},{"location":"quickstart/","text":"Quick Start Hello World Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example. Run this script, then visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example(for examples resp macros). Then let's look at hello function. It generates html or plain text or json or something else sent to our HTTP server. The parameter ctx is of Context type. Context carries all things which we can use in our handler in each request. It contains request information from HTTP server, response information which we transfer to HTTP server Correspondingly and other useful attributes. In the body of function, we can find resp macros. resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we use default settings. You can specify parameters of newSettings too. For example change port attribute or set debug flag. Next add route to our application. \"/\" is the URL we can visit in the web browser. Hello is the handler which processes the request from the web browser and sends \"<h1>Hello, Prologue!</h1>\" to the web browser. Finally use nim c -r app.nim to run our application. Visit localhost:8080 , Hello, Prologue! is displayed in your browser. Command Line Tool logue can be used to initialize your program. Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize a new project. This will create a program structure like this: - helloworld - .env - app.nim - urls.nim - views.nim You must switch to /.../helloworld directory to run app.nim . For example, you can type logue run and open the browser to visit the URL. Debug Mode There are many ways to enable debug mode. If using default settings, debug mode is enabled too. You can also enable them on your own. let settings = newSettings ( debug = true ) If you use JSON config file: { \"prologue\" : { \"address\" : \"\" , \"port\" : 8080 , \"debug\" : true , \"reusePort\" : true , \"appName\" : \"\" , \"secretKey\" : \"Set by yourself\" , } } Set debug = false to disable debug mode. Once debug mode is enabled, the program will display useful logging messages. It is helpful for debugging. But it will slow down the program. If you want to benchmark or release your program, please set debug = false . URL Building Prologue provides a special function urlFor to get the URL from the name of handler. Before using urlFor , you should register the name of handler first. proc hello ( ctx : Context ) {. async .} = resp ctx . urlFor ( \"index\" ) proc index ( ctx : Context ) {. async .} = resp \"Hello world\" var app = newApp () app . get ( \"/hello\" , hello ) app . get ( \"/index\" , index , name = \"index\" ) If you visit localhost:8080/hello , the browser will display /index on the screen. urlFor only supports two forms of Route: 1. /route/hello 2. /route/{parameter}/other . So you can also pass parameters to urlFor . For example urlFor(\"route\", {\"parameter\": \"think\"}) will build /route/think/other . It also supports passing query parameters. Static Files You may want to serve your HTML, CSS files. Static files middleware can be used for this purpose. You should put your static files under /public directory. import prologue import prologue / middlewares / staticfile app . use ( staticFileMiddleware ( \"/public\" )) Redirect You can easily redirect to other URL using redirect function. The default HTTP code for redirct function is Http301. You could use Http302 to move temporarily. The program below redirects to localhost:8080/home . proc redirectHome * ( ctx : Context ) {. async .} = resp redirect ( \"/home\" ) Cookies Prologue provides setCookie , deleteCookie and getCookie to help you with cookies. The handler below will display the name in the cookies from the client if existing. Otherwise AnyOne will be displayed. proc hello ( ctx : Context ) {. async .} = resp ctx . getCookie ( \"name\" , \"Anyone\" ) setCookie sets the (key, value) pair in the HTTP headers. You could also set the expires or maxAge of the cookies. These attributes decide when the survival time of the cookies. deleteCookie will make the specific key expired at once.","title":"QuickStart"},{"location":"quickstart/#quick-start","text":"","title":"Quick Start"},{"location":"quickstart/#hello-world","text":"Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example. Run this script, then visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example(for examples resp macros). Then let's look at hello function. It generates html or plain text or json or something else sent to our HTTP server. The parameter ctx is of Context type. Context carries all things which we can use in our handler in each request. It contains request information from HTTP server, response information which we transfer to HTTP server Correspondingly and other useful attributes. In the body of function, we can find resp macros. resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we use default settings. You can specify parameters of newSettings too. For example change port attribute or set debug flag. Next add route to our application. \"/\" is the URL we can visit in the web browser. Hello is the handler which processes the request from the web browser and sends \"<h1>Hello, Prologue!</h1>\" to the web browser. Finally use nim c -r app.nim to run our application. Visit localhost:8080 , Hello, Prologue! is displayed in your browser.","title":"Hello World"},{"location":"quickstart/#command-line-tool","text":"logue can be used to initialize your program. Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize a new project. This will create a program structure like this: - helloworld - .env - app.nim - urls.nim - views.nim You must switch to /.../helloworld directory to run app.nim . For example, you can type logue run and open the browser to visit the URL.","title":"Command Line Tool"},{"location":"quickstart/#debug-mode","text":"There are many ways to enable debug mode. If using default settings, debug mode is enabled too. You can also enable them on your own. let settings = newSettings ( debug = true ) If you use JSON config file: { \"prologue\" : { \"address\" : \"\" , \"port\" : 8080 , \"debug\" : true , \"reusePort\" : true , \"appName\" : \"\" , \"secretKey\" : \"Set by yourself\" , } } Set debug = false to disable debug mode. Once debug mode is enabled, the program will display useful logging messages. It is helpful for debugging. But it will slow down the program. If you want to benchmark or release your program, please set debug = false .","title":"Debug Mode"},{"location":"quickstart/#url-building","text":"Prologue provides a special function urlFor to get the URL from the name of handler. Before using urlFor , you should register the name of handler first. proc hello ( ctx : Context ) {. async .} = resp ctx . urlFor ( \"index\" ) proc index ( ctx : Context ) {. async .} = resp \"Hello world\" var app = newApp () app . get ( \"/hello\" , hello ) app . get ( \"/index\" , index , name = \"index\" ) If you visit localhost:8080/hello , the browser will display /index on the screen. urlFor only supports two forms of Route: 1. /route/hello 2. /route/{parameter}/other . So you can also pass parameters to urlFor . For example urlFor(\"route\", {\"parameter\": \"think\"}) will build /route/think/other . It also supports passing query parameters.","title":"URL Building"},{"location":"quickstart/#static-files","text":"You may want to serve your HTML, CSS files. Static files middleware can be used for this purpose. You should put your static files under /public directory. import prologue import prologue / middlewares / staticfile app . use ( staticFileMiddleware ( \"/public\" ))","title":"Static Files"},{"location":"quickstart/#redirect","text":"You can easily redirect to other URL using redirect function. The default HTTP code for redirct function is Http301. You could use Http302 to move temporarily. The program below redirects to localhost:8080/home . proc redirectHome * ( ctx : Context ) {. async .} = resp redirect ( \"/home\" )","title":"Redirect"},{"location":"quickstart/#cookies","text":"Prologue provides setCookie , deleteCookie and getCookie to help you with cookies. The handler below will display the name in the cookies from the client if existing. Otherwise AnyOne will be displayed. proc hello ( ctx : Context ) {. async .} = resp ctx . getCookie ( \"name\" , \"Anyone\" ) setCookie sets the (key, value) pair in the HTTP headers. You could also set the expires or maxAge of the cookies. These attributes decide when the survival time of the cookies. deleteCookie will make the specific key expired at once.","title":"Cookies"},{"location":"request/","text":"Request Request contains the information from the HTTP server. You can visit this attribute by using ctx.request . for example, you maybe want to get state from users, you can query the cookies attribute. proc hello ( ctx : Context ) {. async .} = if ctx . request . cookies . hasKey ( \"happy\" ): echo \"Yea, I'm happy\" Request utils request.url Gets the url of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . url request.port Gets the port of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . port . int request.path Gets the path of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . path request.reqMethod Gets the HttpMethod of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . reqMethod request.contentType Gets the contentType of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . contentType request.hostName Gets the hostname of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . hostName","title":"Requests"},{"location":"request/#request","text":"Request contains the information from the HTTP server. You can visit this attribute by using ctx.request . for example, you maybe want to get state from users, you can query the cookies attribute. proc hello ( ctx : Context ) {. async .} = if ctx . request . cookies . hasKey ( \"happy\" ): echo \"Yea, I'm happy\"","title":"Request"},{"location":"request/#request-utils","text":"","title":"Request utils"},{"location":"request/#requesturl","text":"Gets the url of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . url","title":"request.url"},{"location":"request/#requestport","text":"Gets the port of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . port . int","title":"request.port"},{"location":"request/#requestpath","text":"Gets the path of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . path","title":"request.path"},{"location":"request/#requestreqmethod","text":"Gets the HttpMethod of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . reqMethod","title":"request.reqMethod"},{"location":"request/#requestcontenttype","text":"Gets the contentType of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . contentType","title":"request.contentType"},{"location":"request/#requesthostname","text":"Gets the hostname of the request. proc hello ( ctx : Context ) {. async .} = echo ctx . request . hostName","title":"request.hostName"},{"location":"response/","text":"Response Respond by types You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format Respond by error code error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401 Other utils You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders . Send user-defined response Prologue framework will automatically send the final response to the client. You just need to set the attributes of response. It also supports sending response by yourself. For example you can use ctx.respond to send data to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) But this will leads that \"data\" message is sent twice, it's ok for some situations. For example, you may want to send another message, you can change the body of the response. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . response . body = \"message\" First this handler will send \"data\" to the client, then the handler will send \"message\" to the client. However, this may be not the intended behaviour. You want to make sure when you send response by yourself, the framework shouldn't handle the response anymore. You can set the handled attributes of context to true. Now the framework won't handle ctx.response any more, even the error handler won't work. Only \"data\" message is sent to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . handled = true ctx . response . code = Http500 ctx . response . body = \"message\"","title":"Response"},{"location":"response/#response","text":"","title":"Response"},{"location":"response/#respond-by-types","text":"You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format","title":"Respond by types"},{"location":"response/#respond-by-error-code","text":"error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401","title":"Respond by error code"},{"location":"response/#other-utils","text":"You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders .","title":"Other utils"},{"location":"response/#send-user-defined-response","text":"Prologue framework will automatically send the final response to the client. You just need to set the attributes of response. It also supports sending response by yourself. For example you can use ctx.respond to send data to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) But this will leads that \"data\" message is sent twice, it's ok for some situations. For example, you may want to send another message, you can change the body of the response. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . response . body = \"message\" First this handler will send \"data\" to the client, then the handler will send \"message\" to the client. However, this may be not the intended behaviour. You want to make sure when you send response by yourself, the framework shouldn't handle the response anymore. You can set the handled attributes of context to true. Now the framework won't handle ctx.response any more, even the error handler won't work. Only \"data\" message is sent to the client. proc sendResponse ( ctx : Context ) {. async .} = await ctx . respond ( Http200 , \"data\" ) ctx . handled = true ctx . response . code = Http500 ctx . response . body = \"message\"","title":"Send user-defined response"},{"location":"routing/","text":"Routing Routing is the core of web framework. Static Routing Registering handler hello by specifying path, HTTP methods and middlewares. HttpGet is the default HTTP methods. If you have registered a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/hello\" , hello ) # or # app.get(\"/hello\", hello) app . run () You can also use seq[httpMetod] to register the same handler but supports multiple HTTP methods. import prologue # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] ) app . run () Parameters Routing Prologue supports parameters route. You can use getPathParams to get named arguments. Basic Example import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" var app = newApp () app . addRoute ( \"/hello/{name}\" , hello , HttpGet ) app . run () Wildcard Wildcard will match only one URL section. For examples, /static/* only match /static/static.css , /static/etc and so on. You should use greedy( $ ) character to match multiple URL sections. import prologue proc hello * ( ctx : Context ) {. async .} = resp \"Hello, Prologue\" var app = newApp () app . get ( \"/static/*\" , hello ) app . get ( \"/*/static\" , hello ) app . get ( \"/static/templates/{path}/*\" , hello ) app . run () Greedy Greedy character( $ ) will match all the remaining URL sections. But it can only used at the end of the URL. RouteError will be raised if it is used in the middle of the URL. For /test/{param}$ , /test/foo/bar/baz/ is matched. The path parameter is \"foo/bar/baz\". For /test/*$ , /test/static/foo/bar/baz/ is matched. import prologue proc hello * ( ctx : Context ) {. async .} = resp \"Hello, Prologue\" var app = newApp () app . get ( \"/test/{param}$\" , hello ) app . get ( \"/test/static/*$\" , hello ) app . run () Regex Routing Prologue supports regex route. import prologue proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) var app = newApp () app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet ) app . run () Pattern Routing import prologue proc hello ( ctx : Context ) {. async .} = resp \"Hello World!\" const urlPatterns = @[ pattern ( \"/hello\" , hello ) ] var app = newApp () app . addRoute ( urlPatterns , \"\" ) app . run () Group Routing Prologue supports group route. You can add arbitrary levels of route. import prologue var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) level3 = newGroup ( app , \"/level3\" , @[] , level2 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" # /apiv2/hello base . get ( \"/hello\" , hello ) base . get ( \"/hi\" , hi ) base . post ( \"/home\" , home ) # /apiv2/level1/hello level1 . get ( \"/hello\" , hello ) level1 . get ( \"/hi\" , hi ) level1 . post ( \"/home\" , home ) # /apiv2/level1/level2/hello level2 . get ( \"/hello\" , hello ) level2 . get ( \"/hi\" , hi ) level2 . post ( \"/home\" , home ) # /apiv2/level1/level2/level3/hello level3 . get ( \"/hello\" , hello ) level3 . get ( \"/hi\" , hi ) level3 . post ( \"/home\" , home ) app . run () std/with provides a more neat routing fashion: import prologue import std / with var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) level3 = newGroup ( app , \"/level3\" , @[] , level2 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" with base : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/hello with level1 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/level2/hello with level2 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/level2/level3/hello with level3 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) app . run () pattern routing also supports grouping. import prologue var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" let urlpattern1 = @[ pattern ( \"/hello\" , hello ), pattern ( \"/hi\" , hi ) ] urlpattern2 = @[ pattern ( \"/home\" , home ) ] tab = { level1 : urlpattern1 , level2 : urlpattern2 } app . addGroup ( tab ) app . run () Tips You could compile the main program with -d:logueRouteLoose to enable loose route matching. Text and wildcard or text and parameters are considered different. For example /blog/tag/{slug} and /blog/{year}/{id} are not considered as the duplicated routes. If you define /blog/tag/{slug} first, then it will be matched first. Order matters. But /blog/*/{slug} and /blog/{year}/{id} are still duplicated.","title":"Routing"},{"location":"routing/#routing","text":"Routing is the core of web framework.","title":"Routing"},{"location":"routing/#static-routing","text":"Registering handler hello by specifying path, HTTP methods and middlewares. HttpGet is the default HTTP methods. If you have registered a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/hello\" , hello ) # or # app.get(\"/hello\", hello) app . run () You can also use seq[httpMetod] to register the same handler but supports multiple HTTP methods. import prologue # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" var app = newApp () app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] ) app . run ()","title":"Static Routing"},{"location":"routing/#parameters-routing","text":"Prologue supports parameters route. You can use getPathParams to get named arguments.","title":"Parameters Routing"},{"location":"routing/#basic-example","text":"import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" var app = newApp () app . addRoute ( \"/hello/{name}\" , hello , HttpGet ) app . run ()","title":"Basic Example"},{"location":"routing/#wildcard","text":"Wildcard will match only one URL section. For examples, /static/* only match /static/static.css , /static/etc and so on. You should use greedy( $ ) character to match multiple URL sections. import prologue proc hello * ( ctx : Context ) {. async .} = resp \"Hello, Prologue\" var app = newApp () app . get ( \"/static/*\" , hello ) app . get ( \"/*/static\" , hello ) app . get ( \"/static/templates/{path}/*\" , hello ) app . run ()","title":"Wildcard"},{"location":"routing/#greedy","text":"Greedy character( $ ) will match all the remaining URL sections. But it can only used at the end of the URL. RouteError will be raised if it is used in the middle of the URL. For /test/{param}$ , /test/foo/bar/baz/ is matched. The path parameter is \"foo/bar/baz\". For /test/*$ , /test/static/foo/bar/baz/ is matched. import prologue proc hello * ( ctx : Context ) {. async .} = resp \"Hello, Prologue\" var app = newApp () app . get ( \"/test/{param}$\" , hello ) app . get ( \"/test/static/*$\" , hello ) app . run ()","title":"Greedy"},{"location":"routing/#regex-routing","text":"Prologue supports regex route. import prologue proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) var app = newApp () app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet ) app . run ()","title":"Regex Routing"},{"location":"routing/#pattern-routing","text":"import prologue proc hello ( ctx : Context ) {. async .} = resp \"Hello World!\" const urlPatterns = @[ pattern ( \"/hello\" , hello ) ] var app = newApp () app . addRoute ( urlPatterns , \"\" ) app . run ()","title":"Pattern Routing"},{"location":"routing/#group-routing","text":"Prologue supports group route. You can add arbitrary levels of route. import prologue var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) level3 = newGroup ( app , \"/level3\" , @[] , level2 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" # /apiv2/hello base . get ( \"/hello\" , hello ) base . get ( \"/hi\" , hi ) base . post ( \"/home\" , home ) # /apiv2/level1/hello level1 . get ( \"/hello\" , hello ) level1 . get ( \"/hi\" , hi ) level1 . post ( \"/home\" , home ) # /apiv2/level1/level2/hello level2 . get ( \"/hello\" , hello ) level2 . get ( \"/hi\" , hi ) level2 . post ( \"/home\" , home ) # /apiv2/level1/level2/level3/hello level3 . get ( \"/hello\" , hello ) level3 . get ( \"/hi\" , hi ) level3 . post ( \"/home\" , home ) app . run () std/with provides a more neat routing fashion: import prologue import std / with var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) level3 = newGroup ( app , \"/level3\" , @[] , level2 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" with base : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/hello with level1 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/level2/hello with level2 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) # /apiv2/level1/level2/level3/hello with level3 : get ( \"/hello\" , hello ) get ( \"/hi\" , hi ) post ( \"/home\" , home ) app . run () pattern routing also supports grouping. import prologue var app = newApp () base = newGroup ( app , \"/apiv2\" , @[] ) level1 = newGroup ( app , \"/level1\" , @[] , base ) level2 = newGroup ( app , \"/level2\" , @[] , level1 ) proc hello ( ctx : Context ) {. async .} = resp \"Hello\" proc hi ( ctx : Context ) {. async .} = resp \"Hi\" proc home ( ctx : Context ) {. async .} = resp \"Home\" let urlpattern1 = @[ pattern ( \"/hello\" , hello ), pattern ( \"/hi\" , hi ) ] urlpattern2 = @[ pattern ( \"/home\" , home ) ] tab = { level1 : urlpattern1 , level2 : urlpattern2 } app . addGroup ( tab ) app . run ()","title":"Group Routing"},{"location":"routing/#tips","text":"You could compile the main program with -d:logueRouteLoose to enable loose route matching. Text and wildcard or text and parameters are considered different. For example /blog/tag/{slug} and /blog/{year}/{id} are not considered as the duplicated routes. If you define /blog/tag/{slug} first, then it will be matched first. Order matters. But /blog/*/{slug} and /blog/{year}/{id} are still duplicated.","title":"Tips"},{"location":"server/","text":"Server settings Current implementation of Prologue supports two HTTP servers. Some settings may work in one of these backends, and won't work in the other backends. This is called additional settings. Settings If you want to use maxBody attribute which only work in asynchttpserver backend, you can set them with newSettings . newSettings supports data of JSON format. In asynchttpserver backend(namely -d:usestd ), you can set maxBody attribute to respond 413 when the contentLength in HTTP headers is over limitation. In httpx backend, you could set numThreads settings which only work in Unix OS. In windows this setting won't work, the number of threads will always be one. This setting allows user to configure how many threads to run the event loop.","title":"Server Settings"},{"location":"server/#server-settings","text":"Current implementation of Prologue supports two HTTP servers. Some settings may work in one of these backends, and won't work in the other backends. This is called additional settings.","title":"Server settings"},{"location":"server/#settings","text":"If you want to use maxBody attribute which only work in asynchttpserver backend, you can set them with newSettings . newSettings supports data of JSON format. In asynchttpserver backend(namely -d:usestd ), you can set maxBody attribute to respond 413 when the contentLength in HTTP headers is over limitation. In httpx backend, you could set numThreads settings which only work in Unix OS. In windows this setting won't work, the number of threads will always be one. This setting allows user to configure how many threads to run the event loop.","title":"Settings"},{"location":"session/","text":"Session The session helps with storing users' state. If you want to use session or flash messages, you must use sessionMiddleware first. Session based on signed cookie This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important info except for testing. Prologue provides you with sessionMiddleware . Usage First you should register sessionMiddleware in global middlewares or handler's middlewares. import prologue import prologue / middlewares / sessions / signedcookiesession let settings = newSettings () var app = newApp ( settings = settings ) app . use ( sessionMiddleware ( settings )) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog Session based on memory The usage of memory session is similar to signed cookie session. Just change the import statement to import prologue/middlewares/sessions/memorysession . This is meant for testing too. Because the data will be lost if the program stops. import prologue import prologue / middlewares / sessions / memorysession let settings = newSettings () var app = newApp ( settings ) app . use ( sessionMiddleware ( settings )) Session based on redis You should install redis first( logue extension redis ). import prologue import prologue / middlewares / sessions / redissession let settings = newSettings () var app = newApp ( settings ) app . use ( sessionMiddleware ( settings )) Flash messages Sometimes you need to store some messages to session, then you can visit these messages in the next request. They will be used once. Once you have visit these messages, they will be popped from the session. You must use one of session middleware above. import src / prologue import src / prologue / middlewares / signedcookiesession import std / with proc hello ( ctx : Context ) {. async .} = ctx . flash ( \"Please retry again!\" ) resp \"Hello, world\" proc tea ( ctx : Context ) {. async .} = let msg = ctx . getFlashedMsg ( FlashLevel . Info ) if msg . isSome : resp msg . get else : resp \"My tea\" let settings = newSettings () var app = newApp ( settings ) with app : use ( sessionMiddleware ( settings )) get ( \"/\" , hello ) get ( \"/hello\" , hello ) get ( \"/tea\" , tea ) run ()","title":"Session"},{"location":"session/#session","text":"The session helps with storing users' state. If you want to use session or flash messages, you must use sessionMiddleware first.","title":"Session"},{"location":"session/#session-based-on-signed-cookie","text":"This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important info except for testing. Prologue provides you with sessionMiddleware .","title":"Session based on signed cookie"},{"location":"session/#usage","text":"First you should register sessionMiddleware in global middlewares or handler's middlewares. import prologue import prologue / middlewares / sessions / signedcookiesession let settings = newSettings () var app = newApp ( settings = settings ) app . use ( sessionMiddleware ( settings )) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog","title":"Usage"},{"location":"session/#session-based-on-memory","text":"The usage of memory session is similar to signed cookie session. Just change the import statement to import prologue/middlewares/sessions/memorysession . This is meant for testing too. Because the data will be lost if the program stops. import prologue import prologue / middlewares / sessions / memorysession let settings = newSettings () var app = newApp ( settings ) app . use ( sessionMiddleware ( settings ))","title":"Session based on memory"},{"location":"session/#session-based-on-redis","text":"You should install redis first( logue extension redis ). import prologue import prologue / middlewares / sessions / redissession let settings = newSettings () var app = newApp ( settings ) app . use ( sessionMiddleware ( settings ))","title":"Session based on redis"},{"location":"session/#flash-messages","text":"Sometimes you need to store some messages to session, then you can visit these messages in the next request. They will be used once. Once you have visit these messages, they will be popped from the session. You must use one of session middleware above. import src / prologue import src / prologue / middlewares / signedcookiesession import std / with proc hello ( ctx : Context ) {. async .} = ctx . flash ( \"Please retry again!\" ) resp \"Hello, world\" proc tea ( ctx : Context ) {. async .} = let msg = ctx . getFlashedMsg ( FlashLevel . Info ) if msg . isSome : resp msg . get else : resp \"My tea\" let settings = newSettings () var app = newApp ( settings ) with app : use ( sessionMiddleware ( settings )) get ( \"/\" , hello ) get ( \"/hello\" , hello ) get ( \"/tea\" , tea ) run ()","title":"Flash messages"},{"location":"staticfiles/","text":"Static Files Prologue supports serving static files. Send static file Response You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" ) Download files User maybe want to download some files from the server. You can use staticFileResponse to send the file to be downloaded. proc downloadFile ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"index.html\" , \"static\" , downloadName = \"download.html\" ) Serve static files staticfile is implemented as middleware. It should be imported first. You can specify the path of static directories. staticDirs is of varargs[string] type. It contains all the directories of static files which will be checked in every request. import prologue import prologue / middlewares / staticfile var app = newApp ( settings = settings ) app . use ( staticFileMiddleware ( env . get ( \"staticDir\" ))) app . addRoute ( urls . urlPatterns , \"\" ) app . run () Multiple directories: import prologue import prologue / middlewares / staticfile var app = newApp ( settings = settings ) app . use ( staticFileMiddleware ( \"public\" , \"templates\" )) # Or seq[string] # app.use(staticFileMiddleware(@[\"public\", \"templates\"])) # Or array[N, string] # app.use(staticFileMiddleware([\"public\", \"templates\"])) app . addRoute ( urls . urlPatterns , \"\" ) app . run () Serving Favicon You may want to add an icon for your website, you can use a favicon. The browser maybe request /favicon.ico to find an icon. redirctTo is handy for this work. dest is the real path of a favicon. For example, you can put it under static directory. import prologue from prologue / middlewares / staticfile import redirectTo var app = newApp () app . get ( \"/favicon.ico\" , redirectTo ( \"/static/favicon.ico\" )) app . run ()","title":"Static Files"},{"location":"staticfiles/#static-files","text":"Prologue supports serving static files.","title":"Static Files"},{"location":"staticfiles/#send-static-file-response","text":"You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" )","title":"Send static file Response"},{"location":"staticfiles/#download-files","text":"User maybe want to download some files from the server. You can use staticFileResponse to send the file to be downloaded. proc downloadFile ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"index.html\" , \"static\" , downloadName = \"download.html\" )","title":"Download files"},{"location":"staticfiles/#serve-static-files","text":"staticfile is implemented as middleware. It should be imported first. You can specify the path of static directories. staticDirs is of varargs[string] type. It contains all the directories of static files which will be checked in every request. import prologue import prologue / middlewares / staticfile var app = newApp ( settings = settings ) app . use ( staticFileMiddleware ( env . get ( \"staticDir\" ))) app . addRoute ( urls . urlPatterns , \"\" ) app . run () Multiple directories: import prologue import prologue / middlewares / staticfile var app = newApp ( settings = settings ) app . use ( staticFileMiddleware ( \"public\" , \"templates\" )) # Or seq[string] # app.use(staticFileMiddleware(@[\"public\", \"templates\"])) # Or array[N, string] # app.use(staticFileMiddleware([\"public\", \"templates\"])) app . addRoute ( urls . urlPatterns , \"\" ) app . run ()","title":"Serve static files"},{"location":"staticfiles/#serving-favicon","text":"You may want to add an icon for your website, you can use a favicon. The browser maybe request /favicon.ico to find an icon. redirctTo is handy for this work. dest is the real path of a favicon. For example, you can put it under static directory. import prologue from prologue / middlewares / staticfile import redirectTo var app = newApp () app . get ( \"/favicon.ico\" , redirectTo ( \"/static/favicon.ico\" )) app . run ()","title":"Serving Favicon"},{"location":"uploadfile/","text":"Upload Files getUploadFile accepts the name of file in order to get the infos. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when using form parameters and HttpPost method. Context provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from the client. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/local/uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/assets/temp\" ) file . save ( \"tests/assets/temp\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"},{"location":"uploadfile/#upload-files","text":"getUploadFile accepts the name of file in order to get the infos. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when using form parameters and HttpPost method. Context provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from the client. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/local/uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/assets/temp\" ) file . save ( \"tests/assets/temp\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"},{"location":"validation/","text":"Validation Prologue provides lots of helper functions for validating data from users. Single Record Each helper function could be used directly, for examples you want to check whether the content of a string is an int. import prologue / validate / validate let msg = \"Int required\" checkInt = isInt ( msg ) doAssert checkInt ( \"12\" ) == ( true , \"\" ) doAssert checkInt ( \"912.6) == (false, msg) Multiple Records You could also check whether multiple records meets the requirements. import prologue / validate / validate import strtabs var form = newFormValidation ({ \"accepted\" : @[ required (), accepted () ] , \"required\" : @[ required () ] , \"requiredInt\" : @[ required (), isInt () ] , \"minValue\" : @[ required (), isInt (), minValue ( 12 ), maxValue ( 19 ) ] }) let chk1 = form . validate ({ \"required\" : \"on\" , \"accepted\" : \"true\" , \"requiredInt\" : \"12\" , \"minValue\" : \"15\" }. newStringTable ) chk2 = form . validate ({ \"requird\" : \"on\" , \"time\" : \"555\" , \"minValue\" : \"10\" }. newStringTable ) chk3 = form . validate ({ \"requird\" : \"on\" , \"time\" : \"555\" , \"minValue\" : \"10\" }. newStringTable , allMsgs = false ) chk4 = form . validate ({ \"required\" : \"on\" , \"accepted\" : \"true\" , \"requiredInt\" : \"12.5\" , \"minValue\" : \"13\" }. newStringTable , allMsgs = false ) doAssert chk1 == ( true , \"\" ) doAssert not chk2 . hasValue doAssert chk2 . msg == \"Can \\' t find key: accepted \\n Can \\' t find key: \" & \"required \\n Can \\' t find key: requiredInt \\n 10 is not greater than or equal to 12.0! \\n \" doAssert not chk3 . hasValue doAssert chk3 . msg == \"Can \\' t find key: accepted \\n \" doAssert not chk4 . hasValue doAssert chk4 . msg == \"12.5 is not an integer! \\n \"","title":"Validation"},{"location":"validation/#validation","text":"Prologue provides lots of helper functions for validating data from users.","title":"Validation"},{"location":"validation/#single-record","text":"Each helper function could be used directly, for examples you want to check whether the content of a string is an int. import prologue / validate / validate let msg = \"Int required\" checkInt = isInt ( msg ) doAssert checkInt ( \"12\" ) == ( true , \"\" ) doAssert checkInt ( \"912.6) == (false, msg)","title":"Single Record"},{"location":"validation/#multiple-records","text":"You could also check whether multiple records meets the requirements. import prologue / validate / validate import strtabs var form = newFormValidation ({ \"accepted\" : @[ required (), accepted () ] , \"required\" : @[ required () ] , \"requiredInt\" : @[ required (), isInt () ] , \"minValue\" : @[ required (), isInt (), minValue ( 12 ), maxValue ( 19 ) ] }) let chk1 = form . validate ({ \"required\" : \"on\" , \"accepted\" : \"true\" , \"requiredInt\" : \"12\" , \"minValue\" : \"15\" }. newStringTable ) chk2 = form . validate ({ \"requird\" : \"on\" , \"time\" : \"555\" , \"minValue\" : \"10\" }. newStringTable ) chk3 = form . validate ({ \"requird\" : \"on\" , \"time\" : \"555\" , \"minValue\" : \"10\" }. newStringTable , allMsgs = false ) chk4 = form . validate ({ \"required\" : \"on\" , \"accepted\" : \"true\" , \"requiredInt\" : \"12.5\" , \"minValue\" : \"13\" }. newStringTable , allMsgs = false ) doAssert chk1 == ( true , \"\" ) doAssert not chk2 . hasValue doAssert chk2 . msg == \"Can \\' t find key: accepted \\n Can \\' t find key: \" & \"required \\n Can \\' t find key: requiredInt \\n 10 is not greater than or equal to 12.0! \\n \" doAssert not chk3 . hasValue doAssert chk3 . msg == \"Can \\' t find key: accepted \\n \" doAssert not chk4 . hasValue doAssert chk4 . msg == \"12.5 is not an integer! \\n \"","title":"Multiple Records"},{"location":"views/","text":"Views Prologue doesn't provide any templates engines. But we recommend karax to you. karax is a powerful template engines based on DSL. It is suitable for server side rendering. You should use nimble install karax or logue extension karax to install it. import karax / [ karaxdsl , vdom ] const frameworks = [ \"Prologue\" , \"Httpx\" , \"Starlight\" ] proc render * ( L : openarray [ string ] ): string = let vnode = buildHtml ( tdiv ( class = \"mt-3\" )): h1 : text \"Which is my favourite web framework?\" p : text \"echo Prologue\" ul : for item in L : li : text item dl : dt : text \"Is Prologue an elegant web framework?\" dd : text \"Yes\" result = $ vnode echo render ( frameworks ) You can combine them easily and create reusable components for later use. They are just like plain functions. It is very flexible for you to use them. import karax / [ karaxdsl , vdom ] const frameworks = [ \"Prologue\" , \"Httpx\" , \"Starlight\" ] proc prepare ( L : openarray [ string ] ): VNode = result = buildHtml ( tdiv ): ul : for item in L : li : text item dl : dt : text \"Is Prologue an elegant web framework?\" dd : text \"Yes\" proc render * ( L : openarray [ string ] ): VNode = result = buildHtml ( tdiv ( class = \"mt-3\" )): h1 : text \"Which is my favourite web framework?\" p : text \"echo Prologue\" prepare ( L ) echo $ render ( frameworks )","title":"Views"},{"location":"views/#views","text":"Prologue doesn't provide any templates engines. But we recommend karax to you. karax is a powerful template engines based on DSL. It is suitable for server side rendering. You should use nimble install karax or logue extension karax to install it. import karax / [ karaxdsl , vdom ] const frameworks = [ \"Prologue\" , \"Httpx\" , \"Starlight\" ] proc render * ( L : openarray [ string ] ): string = let vnode = buildHtml ( tdiv ( class = \"mt-3\" )): h1 : text \"Which is my favourite web framework?\" p : text \"echo Prologue\" ul : for item in L : li : text item dl : dt : text \"Is Prologue an elegant web framework?\" dd : text \"Yes\" result = $ vnode echo render ( frameworks ) You can combine them easily and create reusable components for later use. They are just like plain functions. It is very flexible for you to use them. import karax / [ karaxdsl , vdom ] const frameworks = [ \"Prologue\" , \"Httpx\" , \"Starlight\" ] proc prepare ( L : openarray [ string ] ): VNode = result = buildHtml ( tdiv ): ul : for item in L : li : text item dl : dt : text \"Is Prologue an elegant web framework?\" dd : text \"Yes\" proc render * ( L : openarray [ string ] ): VNode = result = buildHtml ( tdiv ( class = \"mt-3\" )): h1 : text \"Which is my favourite web framework?\" p : text \"echo Prologue\" prepare ( L ) echo $ render ( frameworks )","title":"Views"},{"location":"websocket/","text":"Websocket Prologue provides websocket supports, you need to install websocketx first( nimble install websocketx or logue extension websocketx ). Echo server example First create a new websocket object, then you can send msgs to the client. Finally, you receive msgs from the client and send them back to the client. import prologue import prologue / websocket proc hello * ( ctx : Context ) {. async .} = var ws = await newWebSocket ( ctx ) await ws . send ( \"Welcome to simple echo server\" ) while ws . readyState == Open : let packet = await ws . receiveStrPacket () await ws . send ( packet ) resp \"<h1>Hello, Prologue!</h1>\" More details You can ref to ws to find more usages.","title":"WebSocket"},{"location":"websocket/#websocket","text":"Prologue provides websocket supports, you need to install websocketx first( nimble install websocketx or logue extension websocketx ).","title":"Websocket"},{"location":"websocket/#echo-server-example","text":"First create a new websocket object, then you can send msgs to the client. Finally, you receive msgs from the client and send them back to the client. import prologue import prologue / websocket proc hello * ( ctx : Context ) {. async .} = var ws = await newWebSocket ( ctx ) await ws . send ( \"Welcome to simple echo server\" ) while ws . readyState == Open : let packet = await ws . receiveStrPacket () await ws . send ( packet ) resp \"<h1>Hello, Prologue!</h1>\"","title":"Echo server example"},{"location":"websocket/#more-details","text":"You can ref to ws to find more usages.","title":"More details"}]}